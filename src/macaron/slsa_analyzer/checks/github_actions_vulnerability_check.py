# Copyright (c) 2025 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This module contains the implementation of the GitHub Actions vulnerabilities check."""

import logging
import os

from sqlalchemy import ForeignKey, String
from sqlalchemy.orm import Mapped, mapped_column

from macaron.database.db_custom_types import DBJsonList
from macaron.database.table_definitions import CheckFacts
from macaron.errors import APIAccessError
from macaron.json_tools import json_extract
from macaron.slsa_analyzer.analyze_context import AnalyzeContext
from macaron.slsa_analyzer.checks.base_check import BaseCheck, CheckResultType
from macaron.slsa_analyzer.checks.check_result import CheckResultData, Confidence, JustificationType
from macaron.slsa_analyzer.ci_service.github_actions.analyzer import GitHubWorkflowNode, GitHubWorkflowType
from macaron.slsa_analyzer.package_registry.osv_dev import OSVDevService
from macaron.slsa_analyzer.registry import registry
from macaron.slsa_analyzer.slsa_req import ReqName

logger: logging.Logger = logging.getLogger(__name__)


class GitHubActionsVulnsFacts(CheckFacts):
    """The ORM mapping for justifications in the GitHub Actions vulnerabilities check."""

    __tablename__ = "_github_actions_vulnerabilities_check"

    #: The primary key.
    id: Mapped[int] = mapped_column(ForeignKey("_check_facts.id"), primary_key=True)  # noqa: A003

    #: The list of vulnerability URLs.
    vulnerability_urls: Mapped[list[str]] = mapped_column(
        DBJsonList, nullable=False, info={"justification": JustificationType.TEXT}
    )

    #: The GitHub Action Identifier.
    github_actions_id: Mapped[str] = mapped_column(
        String, nullable=False, info={"justification": JustificationType.TEXT}
    )

    #: The GitHub Action version.
    github_actions_version: Mapped[str] = mapped_column(
        String, nullable=False, info={"justification": JustificationType.TEXT}
    )

    #: The GitHub Action workflow that calls the vulnerable GitHub Action.
    caller_workflow: Mapped[str] = mapped_column(String, nullable=False, info={"justification": JustificationType.HREF})

    __mapper_args__ = {
        "polymorphic_identity": "_github_actions_vulnerabilities_check",
    }


class GitHubActionsVulnsCheck(BaseCheck):
    """This Check checks whether the GitHub Actions called from the corresponding repo have known vulnerabilities.

    Note: This check analyzes the direct GitHub Actions dependencies only.
    TODO: Check GitHub Actions dependencies recursively.
    """

    def __init__(self) -> None:
        """Initialize instance."""
        check_id = "mcn_githubactions_vulnerabilities_1"
        description = "Check whether the GitHub Actions called from the corresponding repo have known vulnerabilities.."
        depends_on: list[tuple[str, CheckResultType]] = [("mcn_version_control_system_1", CheckResultType.PASSED)]
        eval_reqs = [ReqName.SECURITY]
        super().__init__(check_id=check_id, description=description, depends_on=depends_on, eval_reqs=eval_reqs)

    def run_check(self, ctx: AnalyzeContext) -> CheckResultData:
        """Implement the check in this method.

        Parameters
        ----------
        ctx : AnalyzeContext
            The object containing processed data for the target repo.

        Returns
        -------
        CheckResultData
            The result of the check.
        """
        ci_services = ctx.dynamic_data["ci_services"]

        external_workflows: dict[str, list] = {}
        for ci_info in ci_services:
            for callee in ci_info["callgraph"].bfs():
                if isinstance(callee, GitHubWorkflowNode) and callee.node_type in {
                    GitHubWorkflowType.EXTERNAL,
                    GitHubWorkflowType.REUSABLE,
                }:
                    workflow_name = workflow_version = ""
                    if "@" in callee.name:
                        workflow_name, workflow_version = callee.name.split("@")
                    else:
                        # Most likely we have encountered an internal reusable workflow, which
                        # can be skipped.
                        logger.debug("GitHub Actions workflow %s misses a version. Skipping...", callee.name)
                        continue

                    caller_path = callee.caller.source_path if callee.caller else None

                    # Skip the workflow if `workflow_name` or `workflow_version` are missing,
                    # or if `callee.name` lacks an '@' which can indicate an internal workflow
                    # within the same repo .
                    if not workflow_name or not workflow_version:
                        logger.debug("Workflow %s is not relevant. Skipping...", callee.name)
                        continue

                    ext_workflow: list = external_workflows.get(workflow_name, [])
                    ext_workflow.append(
                        {
                            "version": workflow_version,
                            "caller_path": ci_info["service"].api_client.get_file_link(
                                ctx.component.repository.full_name,
                                ctx.component.repository.commit_sha,
                                file_path=(
                                    ci_info["service"].api_client.get_relative_path_of_workflow(
                                        os.path.basename(caller_path)
                                    )
                                    if caller_path
                                    else ""
                                ),
                            ),
                        }
                    )
                    external_workflows[workflow_name] = ext_workflow

        # If no external GitHub Actions are found, return passed result.
        if not external_workflows:
            return CheckResultData(
                result_tables=[],
                result_type=CheckResultType.PASSED,
            )

        # We first send a batch query to see which GitHub Actions are potentially vulnerable.
        # OSV's querybatch returns minimal results but this allows us to only make subsequent
        # queries to get vulnerability details when needed.
        batch_query = [{"name": k, "ecosystem": "GitHub Actions"} for k, _ in external_workflows.items()]
        batch_vulns = []
        try:
            batch_vulns = OSVDevService.get_vulnerabilities_package_name_batch(batch_query)
        except APIAccessError as error:
            logger.debug(error)

        result_tables: list[CheckFacts] = []
        for vuln_res in batch_vulns:
            vulns: list = []
            workflow_name = vuln_res["name"]
            try:
                vulns = OSVDevService.get_vulnerabilities_package_name(ecosystem="GitHub Actions", name=workflow_name)
            except APIAccessError as error:
                logger.debug(error)
                continue
            for workflow_inv in external_workflows[workflow_name]:
                vuln_mapping = []
                for vuln in vulns:
                    if v_id := json_extract(vuln, ["id"], str):
                        try:
                            if OSVDevService.is_version_affected(
                                vuln,
                                workflow_name,
                                workflow_inv["version"],
                                "GitHub Actions",
                                source_repo=f"https://github.com/{workflow_name}",
                            ):
                                vuln_mapping.append(f"https://osv.dev/vulnerability/{v_id}")
                        except APIAccessError as error:
                            logger.debug(error)
                if vuln_mapping:
                    result_tables.append(
                        GitHubActionsVulnsFacts(
                            vulnerability_urls=vuln_mapping,
                            github_actions_id=workflow_name,
                            github_actions_version=workflow_inv["version"],
                            caller_workflow=workflow_inv["caller_path"],
                            confidence=Confidence.HIGH,
                        )
                    )

        if result_tables:
            return CheckResultData(
                result_tables=result_tables,
                result_type=CheckResultType.FAILED,
            )

        return CheckResultData(
            result_tables=[],
            result_type=CheckResultType.PASSED,
        )


registry.register(GitHubActionsVulnsCheck())
