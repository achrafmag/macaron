# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""
Detect suspicious function calls in the code and trace the arguments back to their original values.

This allows for deeper analysis of potentially malicious behavior.
"""

import ast
import base64
import binascii
import ipaddress
import json
import logging
import os
import re
import subprocess  # nosec
import tempfile
from collections import defaultdict
from typing import Any

import yaml

from macaron.config.defaults import defaults
from macaron.errors import ConfigurationError, HeuristicAnalyzerValueError
from macaron.json_tools import JsonType, json_extract
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIPackageJsonAsset

logger: logging.Logger = logging.getLogger(__name__)

IMPORTS = "imports"
CONSTANTS = "constants"
CALLS = "calls"


class PyPISourcecodeAnalyzer:
    """This class is used to analyze the source code of python PyPI packages. This analyzer is a work in progress.

    This analyzer works in two phases. In the first phase, it will perform a pattern-based scan of all python files
    in the source code, looking for suspicious patterns defined by the YAML file in defaults.ini. By default, this
    will include suspicious package imports, suspicious hardcoded constants, and suspicious function calls. If this
    scan does not find any suspicious activity, the analysis will stop and the package will be marked as benign
    by this analyzer. If the scan does find suspicious activity, the analyzer will move on to the second phase.

    In the second phase, the analyzer will perform dataflow analysis. This will track the flow of suspicious constants
    and the results of suspicious function calls to where they are used, to determine if they are used in a malicious
    manner. Suspicious activity includes data exfiltration, code execution, remote connections, operating system and
    process manipulation, and encoded and obfuscated patterns. The types of activity, and their severity and quantity,
    will then determine the probability of the package being malicious.

    Currently, this analyzer only supports the first phase, and will return simply boolean results on the maliciousness
    of the package.
    """

    EXPECTED_PATTERN_CATEGORIES = [IMPORTS, CONSTANTS, CALLS]

    def __init__(self) -> None:
        """Collect required data for analysing the source code."""
        self.suspicious_patterns = self._load_defaults()
        self.rule_files: list = []

    def _load_defaults(self) -> dict[str, dict[str, list]]:
        """Load the suspicious pattern from suspicious_pattern.yaml.

        Returns
        -------
        dict[str: dict[str, list]]
            The suspicious pattern.

        Raises
        ------
        ConfigurationError
            if the suspicious pattern file is not in the expected format or cannot be accessed.
        """
        suspicious_patterns: dict[str, dict[str, list]] = {}
        section_name = "heuristic.pypi"

        if defaults.has_section(section_name):
            section = defaults[section_name]
        else:
            error_msg = f"Unable to find section {section_name}, which is required to load suspicious patterns."
            logger.debug(error_msg)
            raise ConfigurationError(error_msg)

        configuration_name = "suspicious_patterns_file"
        filename = section.get(configuration_name)
        if filename is None:
            error_msg = f"Unable to find {configuration_name} in configuration file."
            logger.debug(error_msg)
            raise ConfigurationError(error_msg)

        filename = os.path.normpath(filename)
        try:
            with open(filename, encoding="utf-8") as file:
                configured_patterns: dict[str, JsonType] = yaml.safe_load(file)
        except FileNotFoundError as file_error:
            error_msg = f"Unable to locate {filename}"
            logger.debug(error_msg)
            raise ConfigurationError(error_msg) from file_error
        except yaml.YAMLError as yaml_error:
            error_msg = f"Unable to parse {filename} as a yaml file."
            logger.debug(error_msg)
            raise ConfigurationError(error_msg) from yaml_error

        for expected_category in self.EXPECTED_PATTERN_CATEGORIES:
            if expected_category not in configured_patterns:
                error_msg = (
                    f"Expected suspicious pattern category {expected_category} present in"
                    + f" {filename}: must have categories {self.EXPECTED_PATTERN_CATEGORIES}"
                )
                logger.debug(error_msg)
                raise ConfigurationError(error_msg)

        for category, patterns in configured_patterns.items():
            suspicious_patterns[category] = {}
            if isinstance(patterns, list):
                suspicious_patterns[category][category] = patterns
            elif isinstance(patterns, dict):
                for subcategory, subpatterns in patterns.items():
                    if not isinstance(subpatterns, list):
                        error_msg = f"Expected subcategory {subcategory} items to be" + f" a list in {filename}"
                        logger.debug(error_msg)
                        raise ConfigurationError(error_msg)

                    suspicious_patterns[category][subcategory] = subpatterns
            else:
                error_msg = f"Expected category {category} to be either a list" + f" or dictionary in {filename}"
                logger.debug(error_msg)
                raise ConfigurationError(error_msg)

        return suspicious_patterns

    def analyze_patterns(self, pypi_package_json: PyPIPackageJsonAsset) -> tuple[HeuristicResult, dict[str, JsonType]]:
        """Analyze the source code of the package for malicious patterns.

        This is the first phase of the source code analyzer.

        Parameters
        ----------
        pypi_package_json: PyPIPackageJsonAsset
            The PyPI package JSON asset object.

        Returns
        -------
        tuple[HeuristicResult, dict[str, JsonType]]
            Containing the analysis results and relevant patterns identified.

        Raises
        ------
        HeuristicAnalyzerValueError
            if there is no source code available.
        """
        analysis_result: defaultdict = defaultdict(list)
        semgrep_commands: list[str] = ["semgrep", "scan"]
        result: HeuristicResult = HeuristicResult.PASS

        source_code_path = pypi_package_json.package_sourcecode_path
        if not source_code_path:
            error_msg = "Unable to retrieve PyPI package source code path"
            logger.debug(error_msg)
            raise HeuristicAnalyzerValueError(error_msg)

        self._create_rules()
        for rule_file in self.rule_files:
            semgrep_commands.extend(["--config", rule_file.name])
        semgrep_commands.append(source_code_path)

        with tempfile.NamedTemporaryFile(mode="w+", delete=True) as output_json_file:
            semgrep_commands.append(f"--json-output={output_json_file.name}")
            try:
                process = subprocess.run(semgrep_commands, check=True, capture_output=True)  # nosec
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as semgrep_error:
                error_msg = (
                    f"Unable to run semgrep on {source_code_path} with arguments {semgrep_commands}: {semgrep_error}"
                )
                logger.debug(error_msg)
                raise HeuristicAnalyzerValueError(error_msg) from semgrep_error

            if process.returncode != 0:
                error_msg = f"Error running semgrep on {source_code_path} with arguments" f" {process.args}"
                logger.debug(error_msg)
                raise HeuristicAnalyzerValueError(error_msg)

            semgrep_output = json.loads(output_json_file.read())

        if not semgrep_output:
            return result, {}

        semgrep_findings = json_extract(semgrep_output, ["results"], list)
        if not semgrep_findings:
            return result, {}

        result = HeuristicResult.FAIL  # some semgrep rules were triggered
        for finding in semgrep_findings:
            category = json_extract(finding, ["check_id"], str)
            if not category:
                continue

            file = json_extract(finding, ["path"], str)
            start = json_extract(finding, ["start", "line"], int)
            end = json_extract(finding, ["end", "line"], int)
            analysis_result[category].append({"file": file, "start": start, "end": end})

        self._clear_rules()

        return result, dict(analysis_result)

    def analyze_dataflow(self, pypi_package_json: PyPIPackageJsonAsset) -> tuple[HeuristicResult, dict[str, JsonType]]:
        """Analyze the source code of the package for malicious dataflow.

        This is the second phase of the source code analyzer. Currently, this function is a placeholder for future
        work.

        Parameters
        ----------
        pypi_package_json: PyPIPackageJsonAsset
            The PyPI package JSON asset object.

        Returns
        -------
        tuple[HeuristicResult, dict[str, JsonType]]
            Containing the analysis results and relevant dataflows identified.

        Raises
        ------
        HeuristicAnalyzerValueError
            if there is no source code available.
        """
        analysis_result: dict = {}
        result: HeuristicResult = HeuristicResult.SKIP

        source_code = pypi_package_json.package_sourcecode
        if not source_code:
            error_msg = "Unable to retrieve PyPI package source code"
            logger.debug(error_msg)
            raise HeuristicAnalyzerValueError(error_msg)

        for filename, content in source_code.items():
            try:
                _ = ast.parse(content)
            except (SyntaxError, ValueError) as ast_parse_error:
                logger.debug("File %s cannot be parsed as a python file: %s", filename, ast_parse_error)
                continue

            # tracer = DataFlowTracer()
            # tracer.generate_symbol_table(content)

            # functioncall_analyzer = FunctionCallAnalyzer(self.suspicious_pattern, tracer)
            # is_malware, detail_info = functioncall_analyzer.analyze(content)
            # if is_malware:
            #     result = HeuristicResult.FAIL

            # # TODO: Currently, the result collector does not handle the situation that
            # # multiple same filename. In the future, this will be replace with absolute path.
            # if detail_info:
            #     analysis_result[filename] = detail_info

        return result, analysis_result

    def _create_rules(self) -> None:
        rule_list: list[dict[str, Any]] = []
        contents: dict = {}

        if self.rule_files:
            self._clear_rules()

        # import rules
        for category, patterns in self.suspicious_patterns[IMPORTS].items():
            rule: dict[str, Any] = {}
            pattern_list: list = []

            rule["id"] = category
            rule["severity"] = "ERROR"
            rule["languages"] = ["python"]
            rule["message"] = f"Detected suspicious imports from the '{category}' category"

            for pattern in patterns:
                pattern_list.append({"pattern": f"import {pattern}"})
                pattern_list.append({"pattern": f"from {pattern} import $X"})
                pattern_list.append({"pattern": f'__import__("{pattern}")'})

            rule["pattern-either"] = pattern_list
            rule_list.append(rule)

        contents = {"rules": rule_list}

        with tempfile.NamedTemporaryFile(
            "w", prefix=f"{IMPORTS}_", suffix=".yaml", delete=False
        ) as import_patterns_file:
            yaml.dump(contents, import_patterns_file)
            self.rule_files.append(import_patterns_file)

    def _clear_rules(self) -> None:
        for file in self.rule_files:
            file.close()
        self.rule_files.clear()


class DataFlowTracer(ast.NodeVisitor):
    """The class is used to create the symbol table and analyze the dataflow."""

    def __init__(self) -> None:
        self.symbol_table: dict = {}  # Store variable assignments
        self.trace_path: list = []

    def visit_Assign(self, node: ast.Assign) -> None:  # noqa: N802 # pylint: disable=C0103
        """Visit the Assign node and build the symbol table."""
        for target in node.targets:
            if isinstance(target, ast.Name):
                target_name = target.id
                if isinstance(node.value, ast.Name):
                    self.symbol_table[target_name] = str(node.value.id)
                elif isinstance(node.value, ast.Constant):
                    self.symbol_table[target_name] = str(node.value.value)
                # Handle other assignment types as needed (e.g., function calls, lists)
                else:
                    self.symbol_table[target_name] = ast.unparse(node.value)
        self.generic_visit(node)  # Important for visiting nested assign

    def trace_back(self, variable_name: str) -> list:
        """Get the full path of the dataflow.

        Parameters
        ----------
        variable_name: str
                The argument of the function call.

        Returns
        -------
        list
                The path of the dataflow.
        """
        self.trace_path = []
        self._recursive_trace(variable_name)
        return self.trace_path

    def _recursive_trace(self, variable_name: str) -> None:
        """Recursively build the dataflow path by analyzing the symbol table.

        Parameters
        ----------
        variable_name: str
                The argument of the function call.
        """
        if variable_name in self.symbol_table:
            value = self.symbol_table[variable_name]
            if not self.trace_path:
                self.trace_path.extend([variable_name, value])
            else:
                self.trace_path.append(value)
            if (
                isinstance(value, str) and value in self.symbol_table and self.symbol_table[value] != value
            ):  # only trace if it is a var name
                self._recursive_trace(value)

    def generate_symbol_table(self, source_code: str) -> None:
        """Generate the symbol table.

        Parameters
        ----------
        source_code: str
                The source code of the script.
        """
        tree = ast.parse(source_code)
        self.visit(tree)


class FunctionCallAnalyzer(ast.NodeVisitor):
    """This class analyzes Python source code to identify potential suspicious behavior."""

    def __init__(self, suspicious_pattern: dict, tracer: DataFlowTracer) -> None:
        """Initialize the analyzer.

        Parameters
        ----------
        suspicious_pattern: dict
                The suspicious behaviour mainly includes the function call and constant.
        """
        self.suspicious_patterns: dict = suspicious_pattern
        self.analysis_detail: dict = {
            "OS Detection": {},
            "Code Execution": {},
            "Information Collecting": {},
            "Remote Connection": {},
            "Custom Setup": {},
            "Obfuscation": {},
        }
        self.tracer = tracer
        self.is_malware = False

    def visit_Module(self, node: ast.Module) -> None:  # noqa: N802 # pylint: disable=C0103
        """Visit all root node."""
        self.generic_visit(node)

    # TODO: Detect OS might generate false alert.
    # def visit_If(self, node: ast.If) -> None:
    #     """Visit the If node."""
    #     if isinstance(node.test, ast.Compare):
    #         unparsed_expr: str = ast.unparse(node)
    #         # Some malware excute different malicious code based on the victims OS.
    #         for os_detection_constant in self.suspicious_patterns["ast_constant"]["os_detection"]:
    #             if os_detection_constant in unparsed_expr:
    # TODO: This function is required to be implemented with dataflow analysis
    #                 self.analysis_detail["OS Detection"][node.lineno] = unparsed_expr
    #                 self.is_malware = True
    #     self.generic_visit(node)

    def visit_Call(self, node: ast.Call) -> None:  # noqa: N802 # pylint: disable=C0103
        """Visit the Call node."""
        suspicious_calls: dict = self.suspicious_patterns[CALLS]
        suspicious_const: dict = self.suspicious_patterns[CONSTANTS]
        function_call: str = ast.unparse(node.func)
        args: str = " ".join([ast.unparse(arg) for arg in node.args])
        expr: str = ast.unparse(node)
        trace_path: list = self.tracer.trace_back(args)
        path: str = ""
        if trace_path:
            path = " ->".join(trace_path)
        for call_type in suspicious_calls:
            if self._is_malware(suspicious_calls[call_type], function_call):
                for constant_type in suspicious_const:  # Further confirmed by checking the arguments
                    if (
                        self._is_malware(suspicious_const[constant_type], args)
                        or IP().extract_public_ipv4(args)
                        or self._is_malware(suspicious_const[constant_type], Decryptor().base64_decode(args))
                    ):
                        self._summarize_analysis_detail(call_type, node.lineno, expr)
                        self.is_malware = True
                    elif self._is_malware(suspicious_const[constant_type], path):
                        self._summarize_analysis_detail(call_type, node.lineno, expr, path)
                        self.is_malware = True
        self.generic_visit(node)

    def visit_ClassDef(self, node: ast.ClassDef) -> None:  # noqa: N802 # pylint: disable=C0103
        """Visit the ClassDef node. This function is used to detect malicious behavior in setup.py."""
        if not node.bases:
            self.generic_visit(node)
            return

        for base in node.bases:
            if isinstance(base, ast.Name):
                if base.id == "install":
                    # TODO: Not pretty sure including this in setup.py means it is a malware, so the self.is_malware is not updated.
                    self.analysis_detail["Custom Setup"][node.lineno] = node.name
        self.generic_visit(node)

    def _summarize_analysis_detail(
        self, function_call_type: str, lineno: int, expr: str, trace_path: str | None = None
    ) -> None:
        """Store the analysis result in based on different type of malicious behaviour.

        Parameters
        ----------
        function_call_type: str
                The suspcious function call type.
        lineno: int
                The location of the source code block.
        expr: str
                The source code block.
        trace_path: str
                The dataflow path.
        """
        detail = [expr]

        if trace_path:
            detail.append(trace_path)

        match function_call_type:
            case "code_execution":
                self.analysis_detail["Code Execution"][lineno] = detail
            case "info_collecting":
                self.analysis_detail["Information Collecting"][lineno] = detail
            case "remote_connection":
                self.analysis_detail["Remote Connection"][lineno] = detail
            case "obfuscation":
                self.analysis_detail["Obfuscation"][lineno] = detail

    def _is_malware(self, malicious_pattern: list, target: str | None) -> bool:
        """Check the source code matched the suspicious pattern.

        Parameters
        ----------
        malicious_pattern: list
                A collection of the suspicious source code.
        target: str
                The componenet of the source code block.

        Returns
        -------
        bool
                The result.
        """
        if not target:
            return False
        for _ in malicious_pattern:  # pylint: disable=C0103, C0501
            if _ in target:
                return True
        return False

    def analyze(self, source_code: str) -> tuple[bool, dict]:
        """Analyze the source code."""
        tree = ast.parse(source_code)
        self.visit(tree)
        return self.is_malware, self.analysis_detail


class Decryptor:
    """This class includes multiple built-in decryption methods."""

    # Only decrypt the string with the built-in decrypt method; otherwise, provide the source code
    # for the user. And notify them to decrypt using the corresponding decrypt method
    # TODO: Implement more decryption method.

    def __init__(self) -> None:
        pass

    def base64_decode(self, encoded_value: str | bytes) -> str | None:
        """Decode the encoded value."""
        try:
            decoded_bytes = base64.b64decode(encoded_value)
            return decoded_bytes.decode("utf-8")
        except (binascii.Error, UnicodeDecodeError):
            return None


class IP:
    """This class provides the method to identify the IP in the source code."""

    def __init__(self) -> None:
        pass

    def is_valid_public_ipv4(self, ip: str) -> bool:
        """Check whether it is a public IPv4."""
        try:
            ip_obj = ipaddress.ip_address(ip)
            return ip_obj.version == 4 and not ip_obj.is_private and not ip_obj.is_loopback
        except ValueError:
            # If ip_address() raises an error, it's not a valid IP
            return False

    def extract_public_ipv4(self, text: str) -> list:
        """Extract the public IPv4 from the source code."""
        ipv4_pattern = r"\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b"
        all_ips = re.findall(ipv4_pattern, text)
        # Filter valid public IPv4 addresses
        valid_public_ipv4s = []
        for ip in all_ips:
            if self.is_valid_public_ipv4(ip):
                valid_public_ipv4s.append(ip)
        return valid_public_ipv4s
