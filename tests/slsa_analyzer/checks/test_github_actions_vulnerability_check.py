# Copyright (c) 2025 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This module contains tests for the GitHub Actions vulnerabilities check."""

import json
import os
import urllib
from pathlib import Path

import pytest
from pytest_httpserver import HTTPServer

from macaron.code_analyzer.call_graph import BaseNode, CallGraph
from macaron.config.defaults import load_defaults
from macaron.slsa_analyzer.checks.check_result import CheckResultType
from macaron.slsa_analyzer.checks.github_actions_vulnerability_check import GitHubActionsVulnsCheck
from macaron.slsa_analyzer.ci_service.base_ci_service import BaseCIService
from macaron.slsa_analyzer.ci_service.github_actions.analyzer import build_call_graph_from_path
from macaron.slsa_analyzer.provenance.intoto import InTotoV01Payload
from macaron.slsa_analyzer.specs.ci_spec import CIInfo
from macaron.slsa_analyzer.specs.inferred_provenance import InferredProvenance
from tests.conftest import MockAnalyzeContext

RESOURCE_PATH = Path(__file__).parent.joinpath("resources")


def get_ci_info(ci_services: dict[str, BaseCIService], ci_name: str, workflow_path: str) -> CIInfo:
    """Get CIInfo instance."""
    ci_info = CIInfo(
        service=ci_services[ci_name],
        callgraph=CallGraph(BaseNode(), ""),
        provenance_assets=[],
        release={},
        provenances=[],
        build_info_results=InTotoV01Payload(statement=InferredProvenance().payload),
    )
    if ci_name == "github_actions":
        root_node: BaseNode = BaseNode()
        workflow_node = build_call_graph_from_path(root_node, workflow_path=workflow_path, repo_path="")
        root_node.add_callee(workflow_node)
        ci_info["callgraph"] = CallGraph(root_node, "")

    return ci_info


@pytest.mark.parametrize(
    ("ci_name", "expected"),
    [
        (
            "github_actions",
            CheckResultType.FAILED,
        ),
        (
            "jenkins",
            CheckResultType.PASSED,
        ),
    ],
)
def test_github_actions_vulns(
    httpserver: HTTPServer,
    tmp_path: Path,
    macaron_path: Path,
    ci_name: str,
    ci_services: dict[str, BaseCIService],
    expected: str,
) -> None:
    """Test that the check handles repositories correctly."""
    check = GitHubActionsVulnsCheck()

    # Set up the context object.
    ctx = MockAnalyzeContext(macaron_path=macaron_path, output_dir="")
    # Set up responses of OSV API.
    with open(
        os.path.join(RESOURCE_PATH, "osv_files", "tj-actions_changed-files_query.json"), encoding="utf8"
    ) as query:
        query_json = json.load(query)
    with open(
        os.path.join(RESOURCE_PATH, "osv_files", "tj-actions_changed-files_querybatch.json"), encoding="utf8"
    ) as querybatch:
        query_batch_json = json.load(querybatch)

    gha_source_path = os.path.join(RESOURCE_PATH, "github", "workflow_files", "Bradford1040_mainsail_check_locale.yml")

    base_url_parsed = urllib.parse.urlparse(httpserver.url_for(""))
    user_config_input = f"""
    [osv_dev]
    url_netloc = {base_url_parsed.netloc}
    url_scheme = {base_url_parsed.scheme}
    """
    user_config_path = os.path.join(tmp_path, "config.ini")
    with open(user_config_path, "w", encoding="utf-8") as user_config_file:
        user_config_file.write(user_config_input)
    # We don't have to worry about modifying the ``defaults`` object causing test
    # pollution here, since we reload the ``defaults`` object before every test with the
    # ``setup_test`` fixture.
    load_defaults(user_config_path)

    httpserver.expect_request("/v1/query").respond_with_json(query_json)
    httpserver.expect_request("/v1/querybatch").respond_with_json(query_batch_json)

    ctx.dynamic_data["ci_services"] = [get_ci_info(ci_services, ci_name, gha_source_path)]

    assert check.run_check(ctx).result_type == expected
